{
  "name" : "Binary Matrix Factorization",
  "cells" : [ {
    "id" : 0,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Slide1",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Binary Data",
      "extraFields" : { }
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import uk.ac.ucl.cs.mr.acltutorial._\nimport MatrixRenderer._\nimport math._\n\ndef format(vect:Double) = f\"$vect%2.2f\"\n\nval layout = Layout(\n    colHeaderSize=170, rowHeaderSize=220,\n    ch=50, cw=100)\nval random = new scala.util.Random(1)\nval n = 3\nval docRows = for (row <- 0 until n) yield RowLabel(row, \"Doc\" + (row + 1))\nval docCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(random.nextGaussian() + 2.0))\nval docCols = Seq(\n  ColLabel(0,\"the\"),\n  ColLabel(1,\"cat\"),\n  ColLabel(2,\"sat\"))\n\nval docMatrix = Matrix(docCells,docRows,docCols)\n\nval graphRows = Seq(\n  RowLabel(0,\"(Blunsom,Oxford)\"),\n  RowLabel(1,\"(Riedel,UCL)\"), \n  RowLabel(2,\"(Vlachos,Sheffield)\"))\n\nval graphCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,f\"${random.nextInt(2)}\")\nval graphCols = Seq(\n  ColLabel(0,\"worksFor\"),\n  ColLabel(1,\"lecturerAt\"),\n  ColLabel(2,\"profAt\"))\n\n\nval graphMatrix = Matrix(graphCells,graphRows,graphCols)\n//render the matrices\nrender(Seq(docMatrix,graphMatrix),layout)",
      "extraFields" : {
        "showEditor" : "false",
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 3,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "<ul>\n    <li class=\"fragment\" data-fragment-index=\"1\">L2 Loss assumes data is generated by <b>Gaussians</b></li>\n    <li class=\"fragment\" data-fragment-index=\"2\">Unsuitable for <b>binary</b> data</li>\n</ul>",
      "extraFields" : { }
    }
  }, {
    "id" : 4,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "24",
      "extraFields" : { }
    }
  }, {
    "id" : 5,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "<h3>Logistic Loss</h3>\n<h4>Objective</h4>\n$$\n\n  \\sum_{(i,j)\\in\\Omega} \n    \\log(\\class{fragment0 highlight-current-blue}{\\text{sigm} \\langle\\mathbf{u}_i,\\mathbf{v}_j\\rangle})^{y_{ij}} +  \n     \\log(\\class{fragment1 highlight-current-blue}{1-\\text{sigm} \\langle\\mathbf{u}_i,\\mathbf{v}_j\\rangle})^{1 - y_{ij}}\n$$\n<ul>\n    <li class=\"fragment0\">Probability of \\(y_{ij}=1\\)</li>\n    <li class=\"fragment1\">Probability of \\(y_{ij}=0\\)</li>\n</ul>\n\n<div class=\"fragment2\">\n<h4>Gradient Steps (for \\(y_{ij}=1 \\))</h4>\n$$\n\\begin{split}\n\n\\mathbf{u}_i \\leftarrow \\mathbf{u}_i - \\eta \\text{sigm} \\langle\\mathbf{u}_i,\\mathbf{v}_j\\rangle \\mathbf{v}_j \\\\\n\n\\mathbf{v}_j \\leftarrow \\mathbf{v}_j - \\eta \\text{sigm} \\langle\\mathbf{u}_i,\\mathbf{v}_j\\rangle \\mathbf{u}_i\n\n\\end{split}\n$$\n</div>\n\n\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Slide2",
      "extraFields" : { }
    }
  }, {
    "id" : 7,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Equivalent View: Generalized PCA\n\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 8,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import cc.factorie.la._\nimport ml.wolfe.util._\n\ndef randomEmbedding = Range(0,2).map(_ => random.nextGaussian()) \nval rowEmbeddings = Range(0,n).map(row => randomEmbedding)\nval colEmbeddings = Range(0,n).map(row => randomEmbedding)\n\nval colEmbeddingsMatrix = Range(0,n).map(i => colEmbedding(i,3,colEmbeddings(i).map(format))).reduce(_ + _)\nval rowEmbeddingsMatrix = Range(0,n).map(i => rowEmbedding(i,3,rowEmbeddings(i).map(format))).reduce(_ + _)\n\ndef score(row:Int,col:Int) = \n  new DenseTensor1(rowEmbeddings(row).toArray) dot \n  new DenseTensor1(colEmbeddings(col).toArray)\n\nval scores = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(score(row,col)))\n\nval probs = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(Math.sigmoid(score(row,col))))\n\nval labels = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,if (random.nextDouble < Math.sigmoid(score(row,col))) 1 else 0)\n\nval m1 = Matrix(Nil,graphRows,graphCols)\nval m3 = m1 + rowEmbeddingsMatrix + colEmbeddingsMatrix\nval m4 = m3 + Matrix(scores)\nval m5 = m3 + Matrix(probs)\nval m6 = m3 + Matrix(labels)\n\nrender(Seq(m1,m3,m4,m5,m6),layout)\n",
      "extraFields" : {
        "showEditor" : "false",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial._\\nimport MatrixRenderer._\\nimport math._\\n\\ndef format(vect:Double) = f\\\"$vect%2.2f\\\"\\n\\nval layout = Layout(\\n    colHeaderSize=170, rowHeaderSize=220,\\n    ch=50, cw=100)\\nval random = new scala.util.Random(1)\\nval n = 3\\nval docRows = for (row <- 0 until n) yield RowLabel(row, \\\"Doc\\\" + (row + 1))\\nval docCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(random.nextGaussian() + 2.0))\\nval docCols = Seq(\\n  ColLabel(0,\\\"the\\\"),\\n  ColLabel(1,\\\"cat\\\"),\\n  ColLabel(2,\\\"sat\\\"))\\n\\nval docMatrix = Matrix(docCells,docRows,docCols)\\n\\nval graphRows = Seq(\\n  RowLabel(0,\\\"(Blunsom,Oxford)\\\"),\\n  RowLabel(1,\\\"(Riedel,UCL)\\\"), \\n  RowLabel(2,\\\"(Vlachos,Sheffield)\\\"))\\n\\nval graphCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,f\\\"${random.nextInt(2)}\\\")\\nval graphCols = Seq(\\n  ColLabel(0,\\\"worksFor\\\"),\\n  ColLabel(1,\\\"lecturerAt\\\"),\\n  ColLabel(2,\\\"profAt\\\"))\\n\\n\\nval graphMatrix = Matrix(graphCells,graphRows,graphCols)\\n//render the matrices\\nrender(Seq(docMatrix,graphMatrix),layout)\"]"
      }
    }
  }, {
    "id" : 9,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "<ul>\n    <li class=\"fragment1\">Generate Embeddings \\(U\\) and \\(V\\) using Gaussians</li>\n    <li class=\"fragment2\">Calculate natural parameters \\( \\langle\\mathbf{u}_i,\\mathbf{v}_j\\rangle \\)</li>\n    <li class=\"fragment3\">Apply sigmoid to get Bernoulli probabilities</li>\n    <li class=\"fragment4\">Draw a Boolean value from Bernoulli</li>\n</ul>\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 10,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Slide3",
      "extraFields" : { }
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Negative Data",
      "extraFields" : { }
    }
  }, {
    "id" : 12,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import uk.ac.ucl.cs.mr.acltutorial.BinaryMF._\nrender(Seq(allCells,noZeroes,someSampledZeroes,moreSampledZeroes),layout)",
      "extraFields" : {
        "showEditor" : "false",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial._\\nimport MatrixRenderer._\\nimport math._\\n\\ndef format(vect:Double) = f\\\"$vect%2.2f\\\"\\n\\nval layout = Layout(\\n    colHeaderSize=170, rowHeaderSize=220,\\n    ch=50, cw=100)\\nval random = new scala.util.Random(1)\\nval n = 3\\nval docRows = for (row <- 0 until n) yield RowLabel(row, \\\"Doc\\\" + (row + 1))\\nval docCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(random.nextGaussian() + 2.0))\\nval docCols = Seq(\\n  ColLabel(0,\\\"the\\\"),\\n  ColLabel(1,\\\"cat\\\"),\\n  ColLabel(2,\\\"sat\\\"))\\n\\nval docMatrix = Matrix(docCells,docRows,docCols)\\n\\nval graphRows = Seq(\\n  RowLabel(0,\\\"(Blunsom,Oxford)\\\"),\\n  RowLabel(1,\\\"(Riedel,UCL)\\\"), \\n  RowLabel(2,\\\"(Vlachos,Sheffield)\\\"))\\n\\nval graphCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,f\\\"${random.nextInt(2)}\\\")\\nval graphCols = Seq(\\n  ColLabel(0,\\\"worksFor\\\"),\\n  ColLabel(1,\\\"lecturerAt\\\"),\\n  ColLabel(2,\\\"profAt\\\"))\\n\\n\\nval graphMatrix = Matrix(graphCells,graphRows,graphCols)\\n//render the matrices\\nrender(Seq(docMatrix,graphMatrix),layout)\",\"import cc.factorie.la._\\nimport ml.wolfe.util._\\n\\ndef randomEmbedding = Range(0,2).map(_ => random.nextGaussian()) \\nval rowEmbeddings = Range(0,n).map(row => randomEmbedding)\\nval colEmbeddings = Range(0,n).map(row => randomEmbedding)\\n\\nval colEmbeddingsMatrix = Range(0,n).map(i => colEmbedding(i,3,colEmbeddings(i).map(format))).reduce(_ + _)\\nval rowEmbeddingsMatrix = Range(0,n).map(i => rowEmbedding(i,3,rowEmbeddings(i).map(format))).reduce(_ + _)\\n\\ndef score(row:Int,col:Int) = \\n  new DenseTensor1(rowEmbeddings(row).toArray) dot \\n  new DenseTensor1(colEmbeddings(col).toArray)\\n\\nval scores = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(score(row,col)))\\n\\nval probs = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(Math.sigmoid(score(row,col))))\\n\\nval labels = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,if (random.nextDouble < Math.sigmoid(score(row,col))) 1 else 0)\\n\\nval m1 = Matrix(Nil,graphRows,graphCols)\\nval m3 = m1 + rowEmbeddingsMatrix + colEmbeddingsMatrix\\nval m4 = m3 + Matrix(scores)\\nval m5 = m3 + Matrix(probs)\\nval m6 = m3 + Matrix(labels)\\n\\nrender(Seq(m1,m3,m4,m5,m6),layout)\\n\"]"
      }
    }
  }, {
    "id" : 13,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "<ul>\n    <li class=\"fragment1\">Often only positive data is observed</li>\n    <li class=\"fragment2\">Sample unobserved cells and treat as negative</li>\n    <li class=\"fragment3\">Leads to bias, requires many samples</li>\n</ul>\n",
      "extraFields" : { }
    }
  }, {
    "id" : 14,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Slide4",
      "extraFields" : { }
    }
  }, {
    "id" : 15,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Sample During SGD",
      "extraFields" : { }
    }
  }, {
    "id" : 16,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "render(sgdUpdates,layout)",
      "extraFields" : {
        "showEditor" : "false",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial._\\nimport MatrixRenderer._\\nimport math._\\n\\ndef format(vect:Double) = f\\\"$vect%2.2f\\\"\\n\\nval layout = Layout(\\n    colHeaderSize=170, rowHeaderSize=220,\\n    ch=50, cw=100)\\nval random = new scala.util.Random(1)\\nval n = 3\\nval docRows = for (row <- 0 until n) yield RowLabel(row, \\\"Doc\\\" + (row + 1))\\nval docCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(random.nextGaussian() + 2.0))\\nval docCols = Seq(\\n  ColLabel(0,\\\"the\\\"),\\n  ColLabel(1,\\\"cat\\\"),\\n  ColLabel(2,\\\"sat\\\"))\\n\\nval docMatrix = Matrix(docCells,docRows,docCols)\\n\\nval graphRows = Seq(\\n  RowLabel(0,\\\"(Blunsom,Oxford)\\\"),\\n  RowLabel(1,\\\"(Riedel,UCL)\\\"), \\n  RowLabel(2,\\\"(Vlachos,Sheffield)\\\"))\\n\\nval graphCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,f\\\"${random.nextInt(2)}\\\")\\nval graphCols = Seq(\\n  ColLabel(0,\\\"worksFor\\\"),\\n  ColLabel(1,\\\"lecturerAt\\\"),\\n  ColLabel(2,\\\"profAt\\\"))\\n\\n\\nval graphMatrix = Matrix(graphCells,graphRows,graphCols)\\n//render the matrices\\nrender(Seq(docMatrix,graphMatrix),layout)\",\"import cc.factorie.la._\\nimport ml.wolfe.util._\\n\\ndef randomEmbedding = Range(0,2).map(_ => random.nextGaussian()) \\nval rowEmbeddings = Range(0,n).map(row => randomEmbedding)\\nval colEmbeddings = Range(0,n).map(row => randomEmbedding)\\n\\nval colEmbeddingsMatrix = Range(0,n).map(i => colEmbedding(i,3,colEmbeddings(i).map(format))).reduce(_ + _)\\nval rowEmbeddingsMatrix = Range(0,n).map(i => rowEmbedding(i,3,rowEmbeddings(i).map(format))).reduce(_ + _)\\n\\ndef score(row:Int,col:Int) = \\n  new DenseTensor1(rowEmbeddings(row).toArray) dot \\n  new DenseTensor1(colEmbeddings(col).toArray)\\n\\nval scores = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(score(row,col)))\\n\\nval probs = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(Math.sigmoid(score(row,col))))\\n\\nval labels = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,if (random.nextDouble < Math.sigmoid(score(row,col))) 1 else 0)\\n\\nval m1 = Matrix(Nil,graphRows,graphCols)\\nval m3 = m1 + rowEmbeddingsMatrix + colEmbeddingsMatrix\\nval m4 = m3 + Matrix(scores)\\nval m5 = m3 + Matrix(probs)\\nval m6 = m3 + Matrix(labels)\\n\\nrender(Seq(m1,m3,m4,m5,m6),layout)\\n\",\"import uk.ac.ucl.cs.mr.acltutorial.BinaryMF._\\nrender(Seq(allCells,noZeroes,someSampledZeroes,moreSampledZeroes),layout)\"]"
      }
    }
  }, {
    "id" : 17,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "<div style=\"position:relative; width:600px; height:100px; margin:auto; display:block\">\n    <div class=\"fragment1 current-visible\" style=\"position:absolute; top:0;left:0px;\">Sample Positive Cell</div>\n    <div class=\"fragment2 current-visible\" style=\"position:absolute; top:0;left:0px;\">Sample Negative Cell</div>\n</div>",
      "extraFields" : { }
    }
  }, {
    "id" : 18,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "App",
      "extraFields" : { }
    }
  }, {
    "id" : 19,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Application: Relation Extraction\n\n<img src=\"../../assets/figures/KBP_MF_application.png\" height=\"200\">",
      "extraFields" : { }
    }
  }, {
    "id" : 20,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "",
      "extraFields" : { }
    }
  }, {
    "id" : 21,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Results",
      "extraFields" : { }
    }
  }, {
    "id" : 22,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Results\n\n<img src=\"../../assets/figures/uschema-results.png\" height=\"500\">",
      "extraFields" : { }
    }
  } ],
  "config" : { }
}
