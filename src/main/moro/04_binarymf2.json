{
  "name" : "Binary Matrix Factorization",
  "cells" : [ {
    "id" : 0,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Slide1",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Binary Data",
      "extraFields" : { }
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import uk.ac.ucl.cs.mr.acltutorial._\nimport MatrixRenderer._\nimport math._\n\ndef format(vect:Double) = f\"$vect%2.2f\"\n\nval layout = Layout(\n    colHeaderSize=200, rowHeaderSize=220,\n    ch=50, cw=100, numCols = 3, numRows = 3)\nval random = new scala.util.Random(1)\nval n = 3\nval docRows = for (row <- 0 until n) yield RowLabel(row, \"Doc\" + (row + 1))\nval docCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(random.nextGaussian()))\nval docCols = Seq(\n  ColLabel(0,\"the\"),\n  ColLabel(1,\"cat\"),\n  ColLabel(2,\"sat\"))\n\nval docMatrix = Matrix(docCells,docRows,docCols,Seq(1))\n\nval graphRows = Seq(\n  RowLabel(0,\"(Blunson,Oxford)\"),\n  RowLabel(1,\"(Riedel,UCL)\"), \n  RowLabel(2,\"(Vlachos,Sheffield)\"))\n\nval graphCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,f\"${random.nextInt(2)}\")\nval graphCols = Seq(\n  ColLabel(0,\"worksFor\"),\n  ColLabel(1,\"lecturerAt\"),\n  ColLabel(2,\"profAt\"))\n\nval graphMatrix = Matrix(graphCells,graphRows,graphCols)\n//render the matrices\nrender(Seq(docMatrix,graphMatrix),layout)",
      "extraFields" : {
        "showEditor" : "false",
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 3,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "<ul>\n    <li class=\"fragment\" data-fragment-index=\"1\">L2 Loss assumes data is generated by *Gaussians*</li>\n    <li class=\"fragment\" data-fragment-index=\"2\">Unsuitable for **binary** data</li>\n</ul>\n",
      "extraFields" : { }
    }
  }, {
    "id" : 4,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Slide2",
      "extraFields" : { }
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Logistic Loss \n\n* Generate cells using Bernoullis\n    * natural parameter as dot product of embeddings\n    \n$$\np(y_{ij}|\\ldots) = \\text{sigm}(\\langle a_i,v_j \\rangle)\n$$\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import cc.factorie.la._\nimport ml.wolfe.util._\n\ndef randomEmbedding = Range(0,2).map(_ => random.nextGaussian()) \nval rowEmbeddings = Range(0,n).map(row => randomEmbedding)\nval colEmbeddings = Range(0,n).map(row => randomEmbedding)\n\nval colEmbeddingsMatrix = Range(0,n).map(i => colEmbedding(i,3,colEmbeddings(i).map(format))).reduce(_ + _)\nval rowEmbeddingsMatrix = Range(0,n).map(i => rowEmbedding(i,3,rowEmbeddings(i).map(format))).reduce(_ + _)\n\ndef score(row:Int,col:Int) = \n  new DenseTensor1(rowEmbeddings(row).toArray) dot \n  new DenseTensor1(colEmbeddings(col).toArray)\n\nval scores = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(score(row,col)))\n\nval probs = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(Math.sigmoid(score(row,col))))\n\nval labels = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,if (random.nextDouble < Math.sigmoid(score(row,col))) 1 else 0)\n\nval m1 = Matrix(Nil,graphRows,graphCols)\nval m2 = m1 + colEmbeddingsMatrix\nval m3 = m2 + rowEmbeddingsMatrix\nval m4 = m3 + Matrix(scores)\nval m5 = m3 + Matrix(probs)\nval m6 = m3 + Matrix(labels)\n\nrender(Seq(m1,m2,m3,m4,m5,m6),layout)\n",
      "extraFields" : {
        "showEditor" : "false",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial._\\nimport MatrixRenderer._\\nimport math._\\n\\ndef format(vect:Double) = f\\\"$vect%2.2f\\\"\\n\\nval layout = Layout(\\n    colHeaderSize=200, rowHeaderSize=220,\\n    ch=50, cw=100, numCols = 3, numRows = 3)\\nval random = new scala.util.Random(1)\\nval n = 3\\nval docRows = for (row <- 0 until n) yield RowLabel(row, \\\"Doc\\\" + (row + 1))\\nval docCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(random.nextGaussian()))\\nval docCols = Seq(\\n  ColLabel(0,\\\"the\\\"),\\n  ColLabel(1,\\\"cat\\\"),\\n  ColLabel(2,\\\"sat\\\"))\\n\\nval docMatrix = Matrix(docCells,docRows,docCols,Seq(1))\\n\\nval graphRows = Seq(\\n  RowLabel(0,\\\"(Blunson,Oxford)\\\"),\\n  RowLabel(1,\\\"(Riedel,UCL)\\\"), \\n  RowLabel(2,\\\"(Vlachos,Sheffield)\\\"))\\n\\nval graphCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,f\\\"${random.nextInt(2)}\\\")\\nval graphCols = Seq(\\n  ColLabel(0,\\\"worksFor\\\"),\\n  ColLabel(1,\\\"lecturerAt\\\"),\\n  ColLabel(2,\\\"profAt\\\"))\\n\\nval graphMatrix = Matrix(graphCells,graphRows,graphCols)\\n//render the matrices\\nrender(Seq(docMatrix,graphMatrix),layout)\"]"
      }
    }
  }, {
    "id" : 7,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Slide3",
      "extraFields" : { }
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Negative Data\n\n* Often only positive data is observed <!-- .element: class=\"fragment\" data-fragment-index=\"2\" -->\n* Can sample unobserved cells as negative\n* To avoid bias, requires sampling many of these",
      "extraFields" : { }
    }
  }, {
    "id" : 9,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import uk.ac.ucl.cs.mr.acltutorial.BinaryMF._\nval layout = Layout(\n    colHeaderSize=100, rowHeaderSize=120,\n    ch=30, cw=50, numCols = 5, numRows = 5)\nrender(Seq(allCells,noZeroes,someSampledZeroes,moreSampledZeroes),layout)",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial._\\nimport MatrixRenderer._\\nimport math._\\n\\ndef format(vect:Double) = f\\\"$vect%2.2f\\\"\\n\\nval layout = Layout(\\n    colHeaderSize=200, rowHeaderSize=220,\\n    ch=50, cw=100, numCols = 3, numRows = 3)\\nval random = new scala.util.Random(1)\\nval n = 3\\nval docRows = for (row <- 0 until n) yield RowLabel(row, \\\"Doc\\\" + (row + 1))\\nval docCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(random.nextGaussian()))\\nval docCols = Seq(\\n  ColLabel(0,\\\"the\\\"),\\n  ColLabel(1,\\\"cat\\\"),\\n  ColLabel(2,\\\"sat\\\"))\\n\\nval docMatrix = Matrix(docCells,docRows,docCols,Seq(1))\\n\\nval graphRows = Seq(\\n  RowLabel(0,\\\"(Blunson,Oxford)\\\"),\\n  RowLabel(1,\\\"(Riedel,UCL)\\\"), \\n  RowLabel(2,\\\"(Vlachos,Sheffield)\\\"))\\n\\nval graphCells = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,f\\\"${random.nextInt(2)}\\\")\\nval graphCols = Seq(\\n  ColLabel(0,\\\"worksFor\\\"),\\n  ColLabel(1,\\\"lecturerAt\\\"),\\n  ColLabel(2,\\\"profAt\\\"))\\n\\nval graphMatrix = Matrix(graphCells,graphRows,graphCols)\\n//render the matrices\\nrender(Seq(docMatrix,graphMatrix),layout)\",\"import cc.factorie.la._\\nimport ml.wolfe.util._\\n\\ndef randomEmbedding = Range(0,2).map(_ => random.nextGaussian()) \\nval rowEmbeddings = Range(0,n).map(row => randomEmbedding)\\nval colEmbeddings = Range(0,n).map(row => randomEmbedding)\\n\\nval colEmbeddingsMatrix = Range(0,n).map(i => colEmbedding(i,3,colEmbeddings(i).map(format))).reduce(_ + _)\\nval rowEmbeddingsMatrix = Range(0,n).map(i => rowEmbedding(i,3,rowEmbeddings(i).map(format))).reduce(_ + _)\\n\\ndef score(row:Int,col:Int) = \\n  new DenseTensor1(rowEmbeddings(row).toArray) dot \\n  new DenseTensor1(colEmbeddings(col).toArray)\\n\\nval scores = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(score(row,col)))\\n\\nval probs = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,format(Math.sigmoid(score(row,col))))\\n\\nval labels = for (row <- 0 until n; col <- 0 until n) yield Cell(row,col,if (random.nextDouble < Math.sigmoid(score(row,col))) 1 else 0)\\n\\nval m1 = Matrix(Nil,graphRows,graphCols)\\nval m2 = m1 + colEmbeddingsMatrix\\nval m3 = m2 + rowEmbeddingsMatrix\\nval m4 = m3 + Matrix(scores)\\nval m5 = m3 + Matrix(probs)\\nval m6 = m3 + Matrix(labels)\\n\\nrender(Seq(m1,m2,m3,m4,m5,m6),layout)\\n\"]"
      }
    }
  }, {
    "id" : 10,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Slide4",
      "extraFields" : { }
    }
  }, {
    "id" : 11,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Sample During SGD\n\n* Often only positive data is observed <!-- .element: class=\"fragment\" data-fragment-index=\"1\" -->\n",
      "extraFields" : { }
    }
  } ],
  "config" : { }
}
