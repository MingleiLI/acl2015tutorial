{
  "name" : "interactive",
  "cells" : [ {
    "id" : 0,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Interactive",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\nimport ml.wolfe.{Mat, Vect}\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)",
      "extraFields" : {
        "hide_output" : "true",
        "showEditor" : "false",
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val n = 5\nval m = 5 \nval rand = new scala.util.Random(0)\nval rowNames = Seq(\"D1\",\"D2\",\"D3\",\"D4\",\"D5\")\nval colNames = Seq(\"Greece\",\"Tsipras\",\"Germany\",\"crisis\",\"economy\")\nval names = header(rowNames,colNames)\nval M = parseMatrix(\n    \"\"\"1 2 0 0 0\n       0 0 1 0 0\n       0 0 0 1 1 \n       0 0 1 1 1\n       1 2 1 1 0\"\"\")\n",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\"]"
      }
    }
  }, {
    "id" : 3,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Rendered",
      "extraFields" : { }
    }
  }, {
    "id" : 4,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "render(Seq(opacity(matrix(M) + names,0,2)),layout)  ",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\")\\nval colNames = Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 0\\\"\\\"\\\")\\n\"]"
      }
    }
  }, {
    "id" : 5,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "SGD",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\n  val rand = new scala.util.Random(0)\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\n  val A = AV._1; val V = AV._2\n  def update(i: Int, j: Int) = {\n    val a = A(i).copy\n    val v = V(j).copy\n    val y = a dot v\n    A(i) += v * alpha * (M(i, j) - y)\n    V(j) += a * alpha * (M(i, j) - y)\n  }\n  for (i <- Range(0,iters).toList) {\n    update(rand.nextInt(M.dim1), \n           rand.nextInt(M.dim2))\n  }\n  (A, V)\n}",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\")\\nval colNames = Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 0\\\"\\\"\\\")\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \"]"
      }
    }
  }, {
    "id" : 7,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Approximated",
      "extraFields" : { }
    }
  }, {
    "id" : 8,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val (_A,_V) = optimizeL2(M, 2, 10, 0.1)\nval m1 = opacity(matrix(M) + names,0,2).addRectClass(Set(4 -> 4),\"red-box\")\nval m2 = opacity(matrix(dots(_A,_V)) + embeddings(_A,_V) + names,0,2)\nval m3 = numbers(matrix(dots(_A,_V)).addTextClass(Set(4 -> 4),\"red-text\") + names)\nrender(Seq(m1,m2,m3),layout) ",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\")\\nval colNames = Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 0\\\"\\\"\\\")\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \",\"def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\\n  val rand = new scala.util.Random(0)\\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\\n  val A = AV._1; val V = AV._2\\n  def update(i: Int, j: Int) = {\\n    val a = A(i).copy\\n    val v = V(j).copy\\n    val y = a dot v\\n    A(i) += v * alpha * (M(i, j) - y)\\n    V(j) += a * alpha * (M(i, j) - y)\\n  }\\n  for (i <- Range(0,iters).toList) {\\n    update(rand.nextInt(M.dim1), \\n           rand.nextInt(M.dim2))\\n  }\\n  (A, V)\\n}\"]"
      }
    }
  }, {
    "id" : 9,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "2DPlot",
      "extraFields" : { }
    }
  }, {
    "id" : 10,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "points(_A -> rowNames, _V -> colNames) ",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\")\\nval colNames = Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 0\\\"\\\"\\\")\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \",\"def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\\n  val rand = new scala.util.Random(0)\\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\\n  val A = AV._1; val V = AV._2\\n  def update(i: Int, j: Int) = {\\n    val a = A(i).copy\\n    val v = V(j).copy\\n    val y = a dot v\\n    A(i) += v * alpha * (M(i, j) - y)\\n    V(j) += a * alpha * (M(i, j) - y)\\n  }\\n  for (i <- Range(0,iters).toList) {\\n    update(rand.nextInt(M.dim1), \\n           rand.nextInt(M.dim2))\\n  }\\n  (A, V)\\n}\",\"val (_A,_V) = optimizeL2(M, 2, 10, 0.1)\\nval m1 = opacity(matrix(M) + names,0,2).addRectClass(Set(4 -> 4),\\\"red-box\\\")\\nval m2 = opacity(matrix(dots(_A,_V)) + embeddings(_A,_V) + names,0,2)\\nval m3 = numbers(matrix(dots(_A,_V)).addTextClass(Set(4 -> 4),\\\"red-text\\\") + names)\\nrender(Seq(m1,m2,m3),layout) \"]"
      }
    }
  }, {
    "id" : 11,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "SGDIterations",
      "extraFields" : { }
    }
  }, {
    "id" : 12,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val models = for (i <- 0 until 10) yield optimizeL2(M, 2, i * 100, 0.1)\nval matrices = for (m <- models) yield  \n  opacity(matrix(dots(m._1,m._2)) + embeddings(m._1,m._2) + names,0,2)\nval losses = for ((a,v) <- models) yield RawHTML(\"%2.2f\".format(l2Loss(M,dots(a,v))))\nfloatLeft(Seq(render(matrices,layout),fragments(losses)))",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\")\\nval colNames = Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 0\\\"\\\"\\\")\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \",\"def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\\n  val rand = new scala.util.Random(0)\\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\\n  val A = AV._1; val V = AV._2\\n  def update(i: Int, j: Int) = {\\n    val a = A(i).copy\\n    val v = V(j).copy\\n    val y = a dot v\\n    A(i) += v * alpha * (M(i, j) - y)\\n    V(j) += a * alpha * (M(i, j) - y)\\n  }\\n  for (i <- Range(0,iters).toList) {\\n    update(rand.nextInt(M.dim1), \\n           rand.nextInt(M.dim2))\\n  }\\n  (A, V)\\n}\",\"val (_A,_V) = optimizeL2(M, 2, 10, 0.1)\\nval m1 = opacity(matrix(M) + names,0,2).addRectClass(Set(4 -> 4),\\\"red-box\\\")\\nval m2 = opacity(matrix(dots(_A,_V)) + embeddings(_A,_V) + names,0,2)\\nval m3 = numbers(matrix(dots(_A,_V)).addTextClass(Set(4 -> 4),\\\"red-text\\\") + names)\\nrender(Seq(m1,m2,m3),layout) \",\"points(_A -> rowNames, _V -> colNames) \"]"
      }
    }
  }, {
    "id" : 13,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "SGDPlots",
      "extraFields" : { }
    }
  }, {
    "id" : 14,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val pointsGraphs = for ((a,v) <- models) yield points(a -> rowNames, v -> colNames)\nfragments(pointsGraphs)",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\")\\nval colNames = Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 0\\\"\\\"\\\")\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \",\"def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\\n  val rand = new scala.util.Random(0)\\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\\n  val A = AV._1; val V = AV._2\\n  def update(i: Int, j: Int) = {\\n    val a = A(i).copy\\n    val v = V(j).copy\\n    val y = a dot v\\n    A(i) += v * alpha * (M(i, j) - y)\\n    V(j) += a * alpha * (M(i, j) - y)\\n  }\\n  for (i <- Range(0,iters).toList) {\\n    update(rand.nextInt(M.dim1), \\n           rand.nextInt(M.dim2))\\n  }\\n  (A, V)\\n}\",\"val (_A,_V) = optimizeL2(M, 2, 10, 0.1)\\nval m1 = opacity(matrix(M) + names,0,2).addRectClass(Set(4 -> 4),\\\"red-box\\\")\\nval m2 = opacity(matrix(dots(_A,_V)) + embeddings(_A,_V) + names,0,2)\\nval m3 = numbers(matrix(dots(_A,_V)).addTextClass(Set(4 -> 4),\\\"red-text\\\") + names)\\nrender(Seq(m1,m2,m3),layout) \",\"points(_A -> rowNames, _V -> colNames) \",\"val models = for (i <- 0 until 10) yield optimizeL2(M, 2, i * 100, 0.1)\\nval matrices = for (m <- models) yield  \\n  opacity(matrix(dots(m._1,m._2)) + embeddings(m._1,m._2) + names,0,2)\\nval losses = for ((a,v) <- models) yield RawHTML(\\\"%2.2f\\\".format(l2Loss(M,dots(a,v))))\\nfloatLeft(Seq(render(matrices,layout),fragments(losses)))\"]"
      }
    }
  }, {
    "id" : 15,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Binary",
      "extraFields" : { }
    }
  }, {
    "id" : 16,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val layout = Layout(cw = 80, ch = 50, colHeaderSize = 150, rowHeaderSize = 80)\nval rand = new scala.util.Random(0)\nval rowNames = Seq(\"Andy\",\"Tim\",\"Ivan\",\"Rex\",\"Hal\")\nval colNames = Seq(\"greek\",\"european\",\"human\",\"mammal\",\"entity\")\nval names = header(rowNames,colNames)\nval M = parseMatrix(\n    \"\"\"1 1 1 1 1\n       0 1 1 1 1\n       0 0 1 1 0 \n       0 0 0 1 1\n       0 0 0 0 1\"\"\")",
      "extraFields" : {
        "hide_output" : "true",
        "showEditor" : "false",
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\")\\nval colNames = Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 0\\\"\\\"\\\")\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \",\"def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\\n  val rand = new scala.util.Random(0)\\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\\n  val A = AV._1; val V = AV._2\\n  def update(i: Int, j: Int) = {\\n    val a = A(i).copy\\n    val v = V(j).copy\\n    val y = a dot v\\n    A(i) += v * alpha * (M(i, j) - y)\\n    V(j) += a * alpha * (M(i, j) - y)\\n  }\\n  for (i <- Range(0,iters).toList) {\\n    update(rand.nextInt(M.dim1), \\n           rand.nextInt(M.dim2))\\n  }\\n  (A, V)\\n}\",\"val (_A,_V) = optimizeL2(M, 2, 10, 0.1)\\nval m1 = opacity(matrix(M) + names,0,2).addRectClass(Set(4 -> 4),\\\"red-box\\\")\\nval m2 = opacity(matrix(dots(_A,_V)) + embeddings(_A,_V) + names,0,2)\\nval m3 = numbers(matrix(dots(_A,_V)).addTextClass(Set(4 -> 4),\\\"red-text\\\") + names)\\nrender(Seq(m1,m2,m3),layout) \",\"points(_A -> rowNames, _V -> colNames) \",\"val models = for (i <- 0 until 10) yield optimizeL2(M, 2, i * 100, 0.1)\\nval matrices = for (m <- models) yield  \\n  opacity(matrix(dots(m._1,m._2)) + embeddings(m._1,m._2) + names,0,2)\\nval losses = for ((a,v) <- models) yield RawHTML(\\\"%2.2f\\\".format(l2Loss(M,dots(a,v))))\\nfloatLeft(Seq(render(matrices,layout),fragments(losses)))\",\"val pointsGraphs = for ((a,v) <- models) yield points(a -> rowNames, v -> colNames)\\nfragments(pointsGraphs)\"]"
      }
    }
  }, {
    "id" : 17,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val m1 = opacity(matrix(M),-1,1) + names \nval (a,v) = optimizeL2(M, 2, 1000)\nval m2 = opacity(matrix(dots(a,v)),-1,1) + names\nrender(Seq(m1,m2),layout) ",
      "extraFields" : {
        "aggregatedCells" : "[\"import uk.ac.ucl.cs.mr.acltutorial.ManualMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nval layout = Layout(cw = 80, ch = 50, colHeaderSize = 150)\",\"val n = 5\\nval m = 5 \\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\")\\nval colNames = Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 2 0 0 0\\n       0 0 1 0 0\\n       0 0 0 1 1 \\n       0 0 1 1 1\\n       1 2 1 1 0\\\"\\\"\\\")\\n\",\"render(Seq(opacity(matrix(M) + names,0,2)),layout)  \",\"def optimizeL2(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\\n  val rand = new scala.util.Random(0)\\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\\n  val A = AV._1; val V = AV._2\\n  def update(i: Int, j: Int) = {\\n    val a = A(i).copy\\n    val v = V(j).copy\\n    val y = a dot v\\n    A(i) += v * alpha * (M(i, j) - y)\\n    V(j) += a * alpha * (M(i, j) - y)\\n  }\\n  for (i <- Range(0,iters).toList) {\\n    update(rand.nextInt(M.dim1), \\n           rand.nextInt(M.dim2))\\n  }\\n  (A, V)\\n}\",\"val (_A,_V) = optimizeL2(M, 2, 10, 0.1)\\nval m1 = opacity(matrix(M) + names,0,2).addRectClass(Set(4 -> 4),\\\"red-box\\\")\\nval m2 = opacity(matrix(dots(_A,_V)) + embeddings(_A,_V) + names,0,2)\\nval m3 = numbers(matrix(dots(_A,_V)).addTextClass(Set(4 -> 4),\\\"red-text\\\") + names)\\nrender(Seq(m1,m2,m3),layout) \",\"points(_A -> rowNames, _V -> colNames) \",\"val models = for (i <- 0 until 10) yield optimizeL2(M, 2, i * 100, 0.1)\\nval matrices = for (m <- models) yield  \\n  opacity(matrix(dots(m._1,m._2)) + embeddings(m._1,m._2) + names,0,2)\\nval losses = for ((a,v) <- models) yield RawHTML(\\\"%2.2f\\\".format(l2Loss(M,dots(a,v))))\\nfloatLeft(Seq(render(matrices,layout),fragments(losses)))\",\"val pointsGraphs = for ((a,v) <- models) yield points(a -> rowNames, v -> colNames)\\nfragments(pointsGraphs)\",\"val layout = Layout(cw = 80, ch = 50, colHeaderSize = 150, rowHeaderSize = 80)\\nval rand = new scala.util.Random(0)\\nval rowNames = Seq(\\\"Andy\\\",\\\"Tim\\\",\\\"Ivan\\\",\\\"Rex\\\",\\\"Hal\\\")\\nval colNames = Seq(\\\"greek\\\",\\\"european\\\",\\\"human\\\",\\\"mammal\\\",\\\"entity\\\")\\nval names = header(rowNames,colNames)\\nval M = parseMatrix(\\n    \\\"\\\"\\\"1 1 1 1 1\\n       0 1 1 1 1\\n       0 0 1 1 0 \\n       0 0 0 1 1\\n       0 0 0 0 1\\\"\\\"\\\")\"]"
      }
    }
  }, {
    "id" : 18,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "LogisticSGD",
      "extraFields" : { }
    }
  }, {
    "id" : 19,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "def optimizeLogistic(M: Mat, K: Int, iters: Int, alpha:Double = 0.1, initScale:Double = 1.0): (Seq[Vect], Seq[Vect]) = {\n  val rand = new scala.util.Random(0)\n  val AV = initialAV(K, M.dim1, M.dim2, initScale)\n  val A = AV._1; val V = AV._2\n  def update(i: Int, j: Int) = {\n    val a = A(i).copy\n    val v = V(j).copy\n    val y = a dot v\n    A(i) += v * alpha * (M(i, j) - y)\n    V(j) += a * alpha * (M(i, j) - y)\n  }\n  for (i <- Range(0,iters).toList) {\n    update(rand.nextInt(M.dim1), \n           rand.nextInt(M.dim2))\n  }\n  (A, V)\n}",
      "extraFields" : { }
    }
  } ],
  "config" : { }
}
