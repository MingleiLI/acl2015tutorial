{
  "name" : "Collective Matrix Factorization",
  "cells" : [ {
    "id" : 0,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Motivating_Example",
      "extraFields" : { }
    }
  }, {
    "id" : 1,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Arbitrary Database Factorization\n*Objective*: A probabilistic model for any database\n\n*Example*: Health data\n\n<br />\n<img src=\"../../assets/figures/06/relational_database_health.png\" width=\"500\">",
      "extraFields" : { }
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\n\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\nimport ml.wolfe.{Mat, Vect}\nimport ml.wolfe.util.Math._\n\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\ndef valueToOpacity(value: Double) = {\n  val capped = Math.min(Math.max(min, value), max)\n  (capped - min) / (max - min)\n}\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\n  cell.copy(value = \"\", color = color, opacity = valueToOpacity(d))\n})\n}\n\nval entityNames = Seq(\n   Seq(\"Greece\",\"Tsipras\",\"Germany\",\"crisis\",\"economy\"),\n   Seq(\"G\",\"P\",\"E\"),\n   Seq(\"D1\",\"D2\",\"D3\",\"D4\",\"D5\"))\n\nval n1 = entityNames(0).length \nval n2 = entityNames(1).length \nval n3 = entityNames(2).length \nval tuples31 = toTuples(parseMatrix(\n  \"\"\"1 2 0 0 0\n     0 0 1 0 0\n     0 0 0 1 1\n     0 0 1 1 1\n     1 2 1 1 1\"\"\"), n1 + n2, 0)\nval tuples32 = toTuples(parseMatrix(\n  \"\"\"1 0 0\n     0 1 1\n     0 1 1\n     0 1 0\n     1 0 1\"\"\"), n1 + n2, n1)\nval tuples21 = toTuples(parseMatrix(\n  \"\"\"1 1 0 0 0\n     1 1 0 1 1\n     1 1 1 1 1\"\"\"), n1, 0)\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\n    \nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\n\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\n\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\n\nval allEntityNames = entityNames.flatten(x => x)\n\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\n\n",
      "extraFields" : {
        "hide" : "true",
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\nval tuples31t = transpose(tuples31)\nval tuples32t = transpose(tuples32)\nval tuples21t = transpose(tuples21)\nval blk_mat = (opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21++ tuples31t ++ tuples32t ++ tuples21t),0,2) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\n\nrender(Seq(blk_mat),layout)",
      "extraFields" : {
        "hide" : "true",
        "cache" : "false",
        "aggregatedCells" : "[\"\\n\\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nimport ml.wolfe.util.Math._\\n\\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\\ndef valueToOpacity(value: Double) = {\\n  val capped = Math.min(Math.max(min, value), max)\\n  (capped - min) / (max - min)\\n}\\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\\n  cell.copy(value = \\\"\\\", color = color, opacity = valueToOpacity(d))\\n})\\n}\\n\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\n\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\\n    \\nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \\nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\\n\\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\\n\\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\\n\\nval allEntityNames = entityNames.flatten(x => x)\\n\\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\\n\\n\"]"
      }
    }
  }, {
    "id" : 4,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "tworel",
      "extraFields" : { }
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Modeling Two Relations\n\n\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 6,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\n\n\nfragments(Seq(floatLeft(Seq(r31,r32)),r31_r32))\n\n\n",
      "extraFields" : {
        "showEditor" : "false",
        "cache" : "false",
        "aggregatedCells" : "[\"\\n\\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nimport ml.wolfe.util.Math._\\n\\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\\ndef valueToOpacity(value: Double) = {\\n  val capped = Math.min(Math.max(min, value), max)\\n  (capped - min) / (max - min)\\n}\\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\\n  cell.copy(value = \\\"\\\", color = color, opacity = valueToOpacity(d))\\n})\\n}\\n\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\n\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\\n    \\nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \\nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\\n\\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\\n\\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\\n\\nval allEntityNames = entityNames.flatten(x => x)\\n\\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\\n\\n\",\"\\nval tuples31t = transpose(tuples31)\\nval tuples32t = transpose(tuples32)\\nval tuples21t = transpose(tuples21)\\nval blk_mat = (opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21++ tuples31t ++ tuples32t ++ tuples21t),0,2) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\\n\\nrender(Seq(blk_mat),layout)\"]"
      }
    }
  }, {
    "id" : 7,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "1. Document - Word matrix \\\\( Y^{(1)} \\in ( \\Re \\cup \\lbrace ? \\rbrace )^{n\\times F} \\\\)\n2. Document - Label matrix  \\\\( Y^{(2)} \\in \\lbrace 0,1,? \\rbrace ^{n\\times K} \\\\)\n\nRepresenting is a a 2-slices tensor is overly complicated and not needed.\nA simple and effective way to represent it is by concatenating the two matrices into a big \\\\( n\\times (F+K) \\\\) matrix:\n\n\\\\( Y := [ Y^{(1)} \\ Y^{(2)}]  \\\\)\n\nWe can estimate a probabilitic model on \\\\(Y\\\\) by factorizing it.\n\nJust use the binary matrix factorization technique we saw before. This is a new method for supervised classification!\n\n - Handles missing data in the input\n - Can work with partially labelled documents\n - Takes advantage of unlabelled data\n",
      "extraFields" : {
        "hide_output" : "true"
      }
    }
  }, {
    "id" : 8,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "adfs",
      "extraFields" : { }
    }
  }, {
    "id" : 9,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Third Relation: Feature Labelling",
      "extraFields" : { }
    }
  }, {
    "id" : 10,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\n\nfragments(Seq(floatLeft(Seq(r31,r32,r21)),r31_r32_r21))\n\n\n",
      "extraFields" : {
        "showEditor" : "false",
        "aggregatedCells" : "[\"\\n\\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nimport ml.wolfe.util.Math._\\n\\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\\ndef valueToOpacity(value: Double) = {\\n  val capped = Math.min(Math.max(min, value), max)\\n  (capped - min) / (max - min)\\n}\\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\\n  cell.copy(value = \\\"\\\", color = color, opacity = valueToOpacity(d))\\n})\\n}\\n\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\n\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\\n    \\nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \\nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\\n\\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\\n\\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\\n\\nval allEntityNames = entityNames.flatten(x => x)\\n\\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\\n\\n\",\"\\nval tuples31t = transpose(tuples31)\\nval tuples32t = transpose(tuples32)\\nval tuples21t = transpose(tuples21)\\nval blk_mat = (opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21++ tuples31t ++ tuples32t ++ tuples21t),0,2) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\\n\\nrender(Seq(blk_mat),layout)\",\"\\n\\n\\nfragments(Seq(floatLeft(Seq(r31,r32)),r31_r32))\\n\\n\\n\"]"
      }
    }
  }, {
    "id" : 11,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "blk",
      "extraFields" : { }
    }
  }, {
    "id" : 12,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "render(Seq(blk_mat),Layout(cw = 55, ch = 40, colHeaderSize = 140))",
      "extraFields" : {
        "showEditor" : "false",
        "aggregatedCells" : "[\"\\n\\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nimport ml.wolfe.util.Math._\\n\\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\\ndef valueToOpacity(value: Double) = {\\n  val capped = Math.min(Math.max(min, value), max)\\n  (capped - min) / (max - min)\\n}\\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\\n  cell.copy(value = \\\"\\\", color = color, opacity = valueToOpacity(d))\\n})\\n}\\n\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\n\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\\n    \\nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \\nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\\n\\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\\n\\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\\n\\nval allEntityNames = entityNames.flatten(x => x)\\n\\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\\n\\n\",\"\\nval tuples31t = transpose(tuples31)\\nval tuples32t = transpose(tuples32)\\nval tuples21t = transpose(tuples21)\\nval blk_mat = (opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21++ tuples31t ++ tuples32t ++ tuples21t),0,2) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\\n\\nrender(Seq(blk_mat),layout)\",\"\\n\\n\\nfragments(Seq(floatLeft(Seq(r31,r32)),r31_r32))\\n\\n\\n\",\"\\n\\nfragments(Seq(floatLeft(Seq(r31,r32,r21)),r31_r32_r21))\\n\\n\\n\"]"
      }
    }
  }, {
    "id" : 13,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "jkl",
      "extraFields" : { }
    }
  }, {
    "id" : 14,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Modeling Two Relations\nAssume we have 2 relations:\n\n1. Document - Word matrix \\\\( Y^{(1)} \\in ( \\Re \\cup \\lbrace ? \\rbrace )^{n\\times F} \\\\)\n2. Document - Label matrix  \\\\( Y^{(2)} \\in \\lbrace 0,1,? \\rbrace ^{n\\times K} \\\\)\n\nRepresenting is a a 2-slices tensor is overly complicated and not needed.\nA simple and effective way to represent it is by concatenating the two matrices into a big \\\\( n\\times (F+K) \\\\) matrix:\n\n\\\\( Y := [ Y^{(1)} \\ Y^{(2)}]  \\\\)\n\nWe can estimate a probabilitic model on \\\\(Y\\\\) by factorizing it.\n\n - Handles missing data in the input\n - Can work with partially labelled documents\n - Takes advantage of unlabelled data\n",
      "extraFields" : { }
    }
  }, {
    "id" : 15,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Motivating_cont",
      "extraFields" : { }
    }
  }, {
    "id" : 16,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "<h3>Concatenation</h3>\n<ul>\n<li>Document - Word matrix \\(Y^{(1)} \\in ( \\Re \\cup \\lbrace ? \\rbrace )^{N\\times F}\\)\n</li>\n<li>Document - Label matrix  \\(Y^{(2)} \\in \\lbrace 0,1,? \\rbrace ^{N\\times K}\\)\n</li>\n<li>\nWord - Label matrix \\( Y^{(3)} \\in \\lbrace 0, 1 ,? \\rbrace ^{K\\times F} \\)\n</li>\n</ul>\n\nNaive concatenation:\n\n$$\nY := \n\\left[\\begin{array}{cc} \nY^{(3)} & [?]_{K\\times K} \n\\\\\nY^{(1)} & Y^{(2)} \n\\end{array}\\right] \n$$\n\nWe can estimate a probabilitic model on \\(Y\\) by factorizing it. This additional relation enables feature labelling and increase prediction capabilities when similar rare words share similar labels",
      "extraFields" : { }
    }
  }, {
    "id" : 17,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "correctcmf",
      "extraFields" : { }
    }
  }, {
    "id" : 18,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "<h3>Symmetric Block Matrix</h3>\n<ul>\n<li>Document - Word matrix \\(Y^{(1)} \\in ( \\Re \\cup \\lbrace ? \\rbrace )^{N\\times F}\\)\n</li>\n<li>Document - Label matrix  \\(Y^{(2)} \\in \\lbrace 0,1,? \\rbrace ^{N\\times K}\\)\n</li>\n<li>\nWord - Label matrix \\( Y^{(3)} \\in \\lbrace 0, 1 ,? \\rbrace ^{F\\times K} \\)\n</li>\n</ul>\n\nA \\((n + F + K) \\times (n + F + K) \\) symmetric block-matrix:\n\n$$\nY := \n\\left[\\begin{array}{ccc} \n[?]_{F\\times F} & Y^{(3)T} &Y^{(1)T}\n\\\\\nY^{(3)} & [?]_{K\\times K} & Y^{(2)T}\n\\\\\nY^{(1)} & Y^{(2)} & [?]_{N\\times N}\n\\end{array}\\right] \n$$\n\nLet factorize it!",
      "extraFields" : { }
    }
  }, {
    "id" : 19,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "CMFformula",
      "extraFields" : { }
    }
  }, {
    "id" : 20,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Collective Matrix Factorization\n\nWe have \\\\(T\\\\) types of entity with embeddings \\\\(\\mathbf{U} = (\\mathbf{U}^{(1)}, \\cdots, \\mathbf{U}^{(T)})\\\\) and we observe relations between all possible entity types \\\\(\\mathbf{Y} = (\\mathbf{Y}^{(1,1)}, \\mathbf{Y}^{(1,2)}, \\cdots, \\mathbf{Y}^{(T,T)}) \\\\)\n\n\nGeneral Loss functions \\\\(\\ell_{tt'}\\\\):\n\n\\\\(\\mathcal{L}(\\mathbf{U}) = \\sum_{t=1}^T \\sum_{t < t'< T} \\ell_{tt'}(\\mathbf{U}^{(t)}\\mathbf{U}^{(t')T}; \\mathbf{Y}^{(t,t')}||) \\\\)\n\nLet's try SGD!\n",
      "extraFields" : { }
    }
  }, {
    "id" : 21,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "SgdCmf",
      "extraFields" : { }
    }
  }, {
    "id" : 22,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\nval entityNames = Seq(\n   Seq(\"Greece\",\"Tsipras\",\"Germany\",\"crisis\",\"economy\"),\n   Seq(\"G\",\"P\",\"E\"),\n   Seq(\"D1\",\"D2\",\"D3\",\"D4\",\"D5\"))\nval n1 = entityNames(0).length \nval n2 = entityNames(1).length \nval n3 = entityNames(2).length \nval tuples31 = toTuples(parseMatrix(\n  \"\"\"1 2 0 0 0\n     0 0 1 0 0\n     0 0 0 1 1\n     0 0 1 1 1\n     1 2 1 1 1\"\"\"), n1 + n2, 0)\nval tuples32 = toTuples(parseMatrix(\n  \"\"\"1 0 0\n     0 1 1\n     0 1 1\n     0 1 0\n     1 0 1\"\"\"), n1 + n2, n1)\nval tuples21 = toTuples(parseMatrix(\n  \"\"\"1 1 0 0 0\n     1 1 0 1 1\n     1 1 1 1 1\"\"\"), n1, 0)\nval T1 = new Table(l2_type, tuples31)\nval T2 = new Table(l2_type, tuples32)\nval T3 = new Table(l2_type, tuples21)",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"\\n\\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nimport ml.wolfe.util.Math._\\n\\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\\ndef valueToOpacity(value: Double) = {\\n  val capped = Math.min(Math.max(min, value), max)\\n  (capped - min) / (max - min)\\n}\\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\\n  cell.copy(value = \\\"\\\", color = color, opacity = valueToOpacity(d))\\n})\\n}\\n\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\n\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\\n    \\nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \\nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\\n\\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\\n\\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\\n\\nval allEntityNames = entityNames.flatten(x => x)\\n\\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\\n\\n\",\"\\nval tuples31t = transpose(tuples31)\\nval tuples32t = transpose(tuples32)\\nval tuples21t = transpose(tuples21)\\nval blk_mat = (opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21++ tuples31t ++ tuples32t ++ tuples21t),0,2) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\\n\\nrender(Seq(blk_mat),layout)\",\"\\n\\n\\nfragments(Seq(floatLeft(Seq(r31,r32)),r31_r32))\\n\\n\\n\",\"\\n\\nfragments(Seq(floatLeft(Seq(r31,r32,r21)),r31_r32_r21))\\n\\n\\n\",\"render(Seq(blk_mat),Layout(cw = 55, ch = 40, colHeaderSize = 140))\"]"
      }
    }
  }, {
    "id" : 23,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "algo",
      "extraFields" : { }
    }
  }, {
    "id" : 24,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\ndef optimizeCMF(database: Seq[Table], tables_weights: Seq[Double], rk: Int, iters: Int, step_size:Double = 0.01, initScale:Double = 1.0): Seq[Vect] = {\n    val U = initial_embeddings(num_of_entities(database), rk, initScale) // N*rank embedding matrix\n    for (it <- 0 until iters) {    // Loop over SGD iterations\n      // Sampling an observation\n      val relation = sample_discrete(tables_weights)\n      val table = database(relation)\n      val observation = sample_seq(table.observations)\n      //Gradient Step\n      val (i, j, gold) = observation\n      val v1 = U(i).copy\n      val v2 = U(j).copy\n      val dloss = loss_gradient(table.loss_type, v1 dot v2, gold)\n      U(i) -= v2 * step_size * dloss\n      U(j) -= v1 * step_size * dloss\n    }\n    U //output the embedding matrix}\n  }\n\n",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"\\n\\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nimport ml.wolfe.util.Math._\\n\\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\\ndef valueToOpacity(value: Double) = {\\n  val capped = Math.min(Math.max(min, value), max)\\n  (capped - min) / (max - min)\\n}\\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\\n  cell.copy(value = \\\"\\\", color = color, opacity = valueToOpacity(d))\\n})\\n}\\n\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\n\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\\n    \\nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \\nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\\n\\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\\n\\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\\n\\nval allEntityNames = entityNames.flatten(x => x)\\n\\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\\n\\n\",\"\\nval tuples31t = transpose(tuples31)\\nval tuples32t = transpose(tuples32)\\nval tuples21t = transpose(tuples21)\\nval blk_mat = (opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21++ tuples31t ++ tuples32t ++ tuples21t),0,2) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\\n\\nrender(Seq(blk_mat),layout)\",\"\\n\\n\\nfragments(Seq(floatLeft(Seq(r31,r32)),r31_r32))\\n\\n\\n\",\"\\n\\nfragments(Seq(floatLeft(Seq(r31,r32,r21)),r31_r32_r21))\\n\\n\\n\",\"render(Seq(blk_mat),Layout(cw = 55, ch = 40, colHeaderSize = 140))\",\"\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(l2_type, tuples31)\\nval T2 = new Table(l2_type, tuples32)\\nval T3 = new Table(l2_type, tuples21)\"]"
      }
    }
  }, {
    "id" : 25,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\ndef showCMF(U:Seq[Vect]) = {\nval blk_mat_rec = (matrix(dots(U,U)) + embeddings(U,U) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\nval blk_mat_rec2 = opacity(blk_mat_rec,0,2)\nrender(Seq(blk_mat, blk_mat_rec2),Layout(cw = 55, ch = 25, colHeaderSize = 160)) \n}",
      "extraFields" : {
        "hide_output" : "true",
        "aggregatedCells" : "[\"\\n\\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nimport ml.wolfe.util.Math._\\n\\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\\ndef valueToOpacity(value: Double) = {\\n  val capped = Math.min(Math.max(min, value), max)\\n  (capped - min) / (max - min)\\n}\\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\\n  cell.copy(value = \\\"\\\", color = color, opacity = valueToOpacity(d))\\n})\\n}\\n\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\n\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\\n    \\nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \\nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\\n\\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\\n\\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\\n\\nval allEntityNames = entityNames.flatten(x => x)\\n\\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\\n\\n\",\"\\nval tuples31t = transpose(tuples31)\\nval tuples32t = transpose(tuples32)\\nval tuples21t = transpose(tuples21)\\nval blk_mat = (opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21++ tuples31t ++ tuples32t ++ tuples21t),0,2) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\\n\\nrender(Seq(blk_mat),layout)\",\"\\n\\n\\nfragments(Seq(floatLeft(Seq(r31,r32)),r31_r32))\\n\\n\\n\",\"\\n\\nfragments(Seq(floatLeft(Seq(r31,r32,r21)),r31_r32_r21))\\n\\n\\n\",\"render(Seq(blk_mat),Layout(cw = 55, ch = 40, colHeaderSize = 140))\",\"\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(l2_type, tuples31)\\nval T2 = new Table(l2_type, tuples32)\\nval T3 = new Table(l2_type, tuples21)\",\"\\ndef optimizeCMF(database: Seq[Table], tables_weights: Seq[Double], rk: Int, iters: Int, step_size:Double = 0.01, initScale:Double = 1.0): Seq[Vect] = {\\n    val U = initial_embeddings(num_of_entities(database), rk, initScale) // N*rank embedding matrix\\n    for (it <- 0 until iters) {    // Loop over SGD iterations\\n      // Sampling an observation\\n      val relation = sample_discrete(tables_weights)\\n      val table = database(relation)\\n      val observation = sample_seq(table.observations)\\n      //Gradient Step\\n      val (i, j, gold) = observation\\n      val v1 = U(i).copy\\n      val v2 = U(j).copy\\n      val dloss = loss_gradient(table.loss_type, v1 dot v2, gold)\\n      U(i) -= v2 * step_size * dloss\\n      U(j) -= v1 * step_size * dloss\\n    }\\n    U //output the embedding matrix}\\n  }\\n\\n\"]"
      }
    }
  }, {
    "id" : 26,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "Result",
      "extraFields" : { }
    }
  }, {
    "id" : 27,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "val U = optimizeCMF0(Seq(T1, T2, T3), Seq(.3, .3, .4), 3, 10000,.01,.001)\nshowCMF(U)",
      "extraFields" : {
        "cache" : "false",
        "aggregatedCells" : "[\"\\n\\nimport uk.ac.ucl.cs.mr.acltutorial.ManualCMF._\\nimport uk.ac.ucl.cs.mr.acltutorial.MatrixRenderer._\\nimport uk.ac.ucl.cs.mr.acltutorial.Renderer._\\nimport cc.factorie.la.{DenseTensor2, DenseTensor1}\\nimport ml.wolfe.{Mat, Vect}\\nimport ml.wolfe.util.Math._\\n\\ndef opacity(m: Matrix, min: Double = 0, max: Double = 1, color: (Int, Int, Int) = (0, 0, 0)) = {\\ndef valueToOpacity(value: Double) = {\\n  val capped = Math.min(Math.max(min, value), max)\\n  (capped - min) / (max - min)\\n}\\nm.copy(m.cells collect { case cell@Cell(_, _, d: Double, _, _, _, _) =>\\n  cell.copy(value = \\\"\\\", color = color, opacity = valueToOpacity(d))\\n})\\n}\\n\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\n\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(loss_type = l2_type, observations = tuples31)\\nval T2 = new Table(loss_type = l2_type, observations = tuples32)\\nval T3 = new Table(loss_type = l2_type, observations = tuples21)\\n    \\nval layout = Layout(cw = 65, ch = 50, colHeaderSize = 140)    \\nval r31 = render(Seq(opacity(tuplesToMatrix(tuples31),0,2) + header(entityNames(2),entityNames(0))),layout)\\nval r32 = render(Seq(opacity(tuplesToMatrix(tuples32)) + header(entityNames(2),entityNames(1))),layout)\\nval r21 = render(Seq(opacity(tuplesToMatrix(tuples21)) + header(entityNames(1),entityNames(0))),layout)\\n\\nval r31_r32 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32),0,2) + header(entityNames(2),entityNames(0) ++ entityNames(1))),layout)\\n\\nval r31_r32_r21 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21),0,2) + header(entityNames(1) ++ entityNames(2),entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n2))),layout)\\n\\nval allEntityNames = entityNames.flatten(x => x)\\n\\nval r31_r32_r12 = render(Seq(opacity(tuplesToMatrix(tuples31++ tuples32 ++ transpose(tuples21)),0,2) + header(allEntityNames,entityNames(0) ++ entityNames(1)).copy(vRulers = Seq(n1),hRulers = Seq(n3))),layout)\\n\\n\",\"\\nval tuples31t = transpose(tuples31)\\nval tuples32t = transpose(tuples32)\\nval tuples21t = transpose(tuples21)\\nval blk_mat = (opacity(tuplesToMatrix(tuples31++ tuples32 ++ tuples21++ tuples31t ++ tuples32t ++ tuples21t),0,2) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\\n\\nrender(Seq(blk_mat),layout)\",\"\\n\\n\\nfragments(Seq(floatLeft(Seq(r31,r32)),r31_r32))\\n\\n\\n\",\"\\n\\nfragments(Seq(floatLeft(Seq(r31,r32,r21)),r31_r32_r21))\\n\\n\\n\",\"render(Seq(blk_mat),Layout(cw = 55, ch = 40, colHeaderSize = 140))\",\"\\nval entityNames = Seq(\\n   Seq(\\\"Greece\\\",\\\"Tsipras\\\",\\\"Germany\\\",\\\"crisis\\\",\\\"economy\\\"),\\n   Seq(\\\"G\\\",\\\"P\\\",\\\"E\\\"),\\n   Seq(\\\"D1\\\",\\\"D2\\\",\\\"D3\\\",\\\"D4\\\",\\\"D5\\\"))\\nval n1 = entityNames(0).length \\nval n2 = entityNames(1).length \\nval n3 = entityNames(2).length \\nval tuples31 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 2 0 0 0\\n     0 0 1 0 0\\n     0 0 0 1 1\\n     0 0 1 1 1\\n     1 2 1 1 1\\\"\\\"\\\"), n1 + n2, 0)\\nval tuples32 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 0 0\\n     0 1 1\\n     0 1 1\\n     0 1 0\\n     1 0 1\\\"\\\"\\\"), n1 + n2, n1)\\nval tuples21 = toTuples(parseMatrix(\\n  \\\"\\\"\\\"1 1 0 0 0\\n     1 1 0 1 1\\n     1 1 1 1 1\\\"\\\"\\\"), n1, 0)\\nval T1 = new Table(l2_type, tuples31)\\nval T2 = new Table(l2_type, tuples32)\\nval T3 = new Table(l2_type, tuples21)\",\"\\ndef optimizeCMF(database: Seq[Table], tables_weights: Seq[Double], rk: Int, iters: Int, step_size:Double = 0.01, initScale:Double = 1.0): Seq[Vect] = {\\n    val U = initial_embeddings(num_of_entities(database), rk, initScale) // N*rank embedding matrix\\n    for (it <- 0 until iters) {    // Loop over SGD iterations\\n      // Sampling an observation\\n      val relation = sample_discrete(tables_weights)\\n      val table = database(relation)\\n      val observation = sample_seq(table.observations)\\n      //Gradient Step\\n      val (i, j, gold) = observation\\n      val v1 = U(i).copy\\n      val v2 = U(j).copy\\n      val dloss = loss_gradient(table.loss_type, v1 dot v2, gold)\\n      U(i) -= v2 * step_size * dloss\\n      U(j) -= v1 * step_size * dloss\\n    }\\n    U //output the embedding matrix}\\n  }\\n\\n\",\"\\ndef showCMF(U:Seq[Vect]) = {\\nval blk_mat_rec = (matrix(dots(U,U)) + embeddings(U,U) + header(allEntityNames,allEntityNames)).copy(vRulers = Seq(n1,n1+n2),hRulers = Seq(n1,n1+n2))\\nval blk_mat_rec2 = opacity(blk_mat_rec,0,2)\\nrender(Seq(blk_mat, blk_mat_rec2),Layout(cw = 55, ch = 25, colHeaderSize = 160)) \\n}\"]"
      }
    }
  }, {
    "id" : 28,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "generalization",
      "extraFields" : { }
    }
  }, {
    "id" : 29,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Generalization to Arbitrary Databases\n\n<br />\n<img src=\"../../assets/figures/06/cmf_databases.png\" width=\"95%\">",
      "extraFields" : { }
    }
  }, {
    "id" : 30,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "example_denoising_faces",
      "extraFields" : { }
    }
  }, {
    "id" : 31,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Example: Augmented Multi-View\n*Objective*: Predict one view given the other\n\nPixel similarity should help. We create a binary matrix linking pixels.\n\n- Relation 1: pixel intensity value in the first image (real)\n- Relation 2: pixel intensity value in the second image (real)\n- Relation 3: Relative similarity between pixels (binary)\n\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 32,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "amv",
      "extraFields" : { }
    }
  }, {
    "id" : 33,
    "compiler" : "html",
    "input" : {
      "sessionId" : null,
      "code" : "\n<img src=\"../../assets/figures/06/faces.png\" width=\"40%\">\n<img src=\"../../assets/figures/06/faces_expt.png\" width=\"40%\">\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 34,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "flikr",
      "extraFields" : { }
    }
  }, {
    "id" : 35,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Example: Social Media Data (Flickr)\n\n<br />\n<img src=\"../../assets/figures/07/flickr.png\" width=\"90%\">\n",
      "extraFields" : { }
    }
  }, {
    "id" : 36,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "BayesianCMF",
      "extraFields" : { }
    }
  }, {
    "id" : 37,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Bayesian Modelling\nCMF: many regularization parameters.\n\nTuning is painful\n\nBayesian learning: principled automatic tuning\n\n1. Choice of a prior \\\\(P(\\mathbf{U},\\mathbf{V})\\\\)\n2. Find (approximate!) the posterior \\\\(P(\\mathbf{Y}|\\mathbf{U},\\mathbf{V})\\\\)\n\nAlgorithms:\n- Sampling\n    - Gibbs sampling: Salakhutdinov et al., 2008\n    - HMC: Mohamed et al., 2009\n- Variational Inference\n    - Variational Bayes: Raiko et al., 2008          \n    - Expectation Propagation: Stern et al., 2009",
      "extraFields" : { }
    }
  }, {
    "id" : 38,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "BayesianMatrixFactorization",
      "extraFields" : { }
    }
  }, {
    "id" : 39,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Bayesian Matrix Factorization\n\nIndependent Gaussian Priors: \\\\(P(\\mathbf{U},\\mathbf{V}) \\propto e^{-\\lambda (||\\mathbf{U}||_F^2 + ||\\mathbf{V}||_F^2)} \\\\)\n\nHomoscedastic Gaussian likelihood: \\\\(P(\\mathbf{Y}|\\mathbf{U},\\mathbf{V}) \\propto e^{-\\frac{1}{\\sigma^2} (||\\mathbf{U}\\mathbf{V}^T - \\mathbf{Y}||_F^2)} \\\\)\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 40,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "algobmf",
      "extraFields" : { }
    }
  }, {
    "id" : 41,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Algorithms for Bayesian Matrix Factorization\n\n*Block Gibbs sampling* \n\n- Sample \\\\(\\mathbf{u_i}|\\mathbf{V}, \\mathbf{Y}_{i:}\\\\) for \\\\(i=1,\\cdots,N\\\\)\n- Sample \\\\(\\mathbf{v_j}|\\mathbf{U}, \\mathbf{Y}_{:j}\\\\) for \\\\(j=1,\\cdots,M\\\\)\n\n*Variational Bayes* : Fully factorized approximation: \\\\( Q(\\mathbf{U},\\mathbf{V}) = \\prod_{i=1}^N Q(\\mathbf{u_i}) \\prod_{j=1}^M Q(\\mathbf{v_j}) \\\\)\n\n- Compute  \\\\(Q(\\mathbf{u}_i)\\\\) based on \\\\(\\mathbf{V}\\\\) and \\\\(\\mathbf{Y}_{i:}\\\\)\n- Compute  \\\\(Q(\\mathbf{v}_j)\\\\) based on \\\\(\\mathbf{U}\\\\) and \\\\(\\mathbf{Y}_{:j}\\\\)",
      "extraFields" : { }
    }
  }, {
    "id" : 42,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "BaysesianCMFdetails",
      "extraFields" : { }
    }
  }, {
    "id" : 43,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Bayesian Collective Matrix Factorization\n\nWe have \\\\(T\\\\) types of entity with embeddings \\\\(\\mathbf{U} = (\\mathbf{U}^{(1)}, \\cdots, \\mathbf{U}^{(T)})\\\\) and we observe relations between all possible entity types \\\\(\\mathbf{Y} = (\\mathbf{Y}^{(1,1)}, \\mathbf{Y}^{(1,2)}, \\cdots, \\mathbf{Y}^{(T,T)}) \\\\)\n\nIndependent Gaussian Priors: \\\\(P(\\mathbf{U}) \\propto e^{-\\sum_{t=1}^T \\lambda_t (||\\mathbf{U}^{(t)}||_F^2} \\\\)\n\nPer-relation Homoscedastic Gaussian likelihood: \\\\(P(\\mathbf{Y}|\\mathbf{U}) \\propto \\prod_{t=1}^T \\prod_{t < t'< T} e^{-\\frac{1}{\\sigma_{tt'}^2} (||\\mathbf{U}^{(t)}\\mathbf{U}^{(t')T} - \\mathbf{Y}^{(t,t')}||_F^2)} \\\\)\n",
      "extraFields" : { }
    }
  }, {
    "id" : 44,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "bcmf",
      "extraFields" : { }
    }
  }, {
    "id" : 45,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Algorithms for Bayesian CMF\n\n*Block Gibbs sampling*\n\n- For each type \\\\(t=1,\\cdots,T\\\\)\n    - Sample \\\\(\\mathbf{u^{(t)}_i}|\\mathbf{U^{(-t)}}, \\mathbf{Y}\\\\) for \\\\(i=1,\\cdots,N_t\\\\)\n\n*Variational Bayes* : Fully factorized approximation: \\\\( Q(\\mathbf{U}) = \\prod_{t=1}^T \\prod_{i=1}^{N_t} Q(\\mathbf{u}_i^{(t)})  \\\\)\n\n- Compute  \\\\(Q(\\mathbf{u}_i^{(t)})\\\\) based on \\\\(\\mathbf{U}^{(-t)}\\\\) and \\\\(\\mathbf{Y}\\\\)\n-\n\nNow we can maximize the likelihood with respect to \\\\(\\sigma_{tt'}\\\\) and \\\\(\\lambda_t\\\\) with \\\\(t,t'\\\\) \n",
      "extraFields" : { }
    }
  }, {
    "id" : 46,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "genes",
      "extraFields" : { }
    }
  }, {
    "id" : 47,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Gene Expression Data Experiment\n\n40 patients with breast cancer\n\n* *Views*: 2 measurements of 4287 genes.\n\n* *Task*: predicting random missing entries\n\n<br />\n<img src=\"../../assets/figures/06/gene_expression.png\" width=\"500\">\n\n\n\n\n",
      "extraFields" : { }
    }
  }, {
    "id" : 48,
    "compiler" : "section",
    "input" : {
      "sessionId" : null,
      "code" : "conclusion",
      "extraFields" : { }
    }
  }, {
    "id" : 49,
    "compiler" : "markdown",
    "input" : {
      "sessionId" : null,
      "code" : "### Conclusion to Collective Matrix Factorization\n\n#### Collective Matrix Factorization and Tensor Factorization: \n  * Learn §more by fusing multiple databases\n  * flexible and generic model for relational data\n  * Bayesian learning : automatic tuning of parameters and complexity\n\n#### Collective Matrix Factorization vs. Tensor Factorization: \n  * CMF is easier because it deals only with matrices\n  * CMF = typed data. Tensor = multi-relational   \n  * Augmented multi-view: common setup\n\n",
      "extraFields" : { }
    }
  } ],
  "config" : { }
}
